input {
  beats {
    port => 5044
  }
  
  # Direct log input from applications (structured JSON logs)
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # HTTP endpoint for frontend/scanner logs
  http {
    port => 8080
    codec => json
  }
}

filter {
  # Handle structured logs from our logging framework
  if [@timestamp] {
    # Already has structured timestamp, use it
    date {
      match => [ "@timestamp", "ISO8601" ]
    }
  } else if [timestamp] {
    # Legacy timestamp field
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS" ]
    }
  }
  
  # Parse JSON logs from container stdout
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
    }
  }
  
  # Ensure log level is uppercase
  if [level] {
    mutate {
      uppercase => [ "level" ]
    }
  }
  
  # Add service information based on container name (fallback)
  if [container] and [container][name] and ![service] {
    if [container][name] =~ /bilten-backend/ {
      mutate {
        add_field => { "service" => "backend" }
        add_field => { "component" => "api" }
      }
    } else if [container][name] =~ /bilten-frontend/ {
      mutate {
        add_field => { "service" => "frontend" }
        add_field => { "component" => "web" }
      }
    } else if [container][name] =~ /bilten-gateway/ {
      mutate {
        add_field => { "service" => "gateway" }
        add_field => { "component" => "proxy" }
      }
    } else if [container][name] =~ /bilten-scanner/ {
      mutate {
        add_field => { "service" => "scanner" }
        add_field => { "component" => "mobile" }
      }
    }
  }
  
  # Set default service if not present
  if ![service] {
    mutate {
      add_field => { "service" => "unknown" }
    }
  }
  
  # Set default component if not present
  if ![component] {
    mutate {
      add_field => { "component" => "main" }
    }
  }
  
  # Parse traditional HTTP access logs (Apache/Nginx format)
  if [message] =~ /^\d+\.\d+\.\d+\.\d+/ {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
    }
    
    if [timestamp] {
      date {
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      }
    }
    
    mutate {
      convert => { "response" => "integer" }
      convert => { "bytes" => "integer" }
    }
    
    # Tag as access log
    mutate {
      add_tag => [ "access_log" ]
      add_field => { "log_type" => "access" }
    }
  }
  
  # Handle error logs specifically
  if [level] == "ERROR" {
    mutate {
      add_tag => [ "error" ]
    }
  }
  
  # Handle HTTP logs specifically
  if [level] == "HTTP" or "access_log" in [tags] {
    mutate {
      add_tag => [ "http" ]
      add_field => { "log_type" => "http" }
    }
  }
  
  # Add environment-specific tags
  if [environment] {
    mutate {
      add_tag => [ "env_%{environment}" ]
    }
  }
  
  # Add service-specific tags
  if [service] {
    mutate {
      add_tag => [ "service_%{service}" ]
    }
  }
  
  # Parse user agent for frontend/scanner logs
  if [userAgent] {
    useragent {
      source => "userAgent"
      target => "user_agent"
    }
  }
  
  # Geolocate IP addresses (if available)
  if [ip] {
    geoip {
      source => "ip"
      target => "geoip"
    }
  }
  
  # Remove sensitive information
  if [headers] and [headers][authorization] {
    mutate {
      update => { "[headers][authorization]" => "[REDACTED]" }
    }
  }
  
  # Clean up fields
  mutate {
    remove_field => [ "host", "agent", "ecs", "input", "log" ]
  }
}

output {
  # Main Elasticsearch output
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "bilten-logs-%{+YYYY.MM.dd}"
    template_name => "bilten-logs"
    template => "/usr/share/logstash/templates/bilten-logs-template.json"
    template_overwrite => true
  }
  
  # Separate index for error logs
  if [level] == "ERROR" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "bilten-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Separate index for HTTP access logs
  if "http" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "bilten-access-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (remove in production)
  if [environment] != "production" {
    stdout {
      codec => rubydebug
    }
  }
}